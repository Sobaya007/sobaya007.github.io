<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>そばやのブログ</title>
    <link>https://sobaya007.github.io/</link>
    <description>Recent content on そばやのブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 18 May 2019 20:58:11 +0900</lastBuildDate>
    
	<atom:link href="https://sobaya007.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>git challenge ♯11に出場しました！</title>
      <link>https://sobaya007.github.io/2019/05/18/git-challenge-11%E3%81%AB%E5%87%BA%E5%A0%B4%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F/</link>
      <pubDate>Sat, 18 May 2019 20:58:11 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/05/18/git-challenge-11%E3%81%AB%E5%87%BA%E5%A0%B4%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F/</guid>
      <description>git challengeとは mixiさんの運営している学生向けのイベント。
gitにまつわるおもしろ問題を解く会。
当日の流れ 時系列順にあったことを書いていこうと思います。
10:40 受付開始 はい pic.twitter.com/27j23vc91W
&amp;mdash; そばや (@sobaya007) May 18, 2019  受付開始から15分ほど遅れること入場。
既にほとんどの参加者はこの時点で集まっていたようです。
ここで相方の青のりさんとのご挨拶タイム。後にわかったことですが、秋葉原でジャンク品を漁っては復元する系のプロの方でした。
多分11:00すぎくらい 説明兼LT開始 さっそく本日のルール等の説明がはじまります。
ルール説明に入るかなーというくらいのタイミングで、「参加者が一人来ていない」ということがわかりました。 え、はやくない、今電車乗ったけど
&amp;mdash; やまだ (@ymdtr) May 18, 2019  犯人はこいつです。
待っていても埒が明かないので説明は粛々と開始。
この時点で問題の回答手順等がゆるふわにわかるようになります。
ちなみに本大会からスコアボードが新システムに変わったそうで、見てみたら中身がHaskellとElm製でした。
趣味が現れていて大変すばらしい！
ついでにこれはOSSなので問題さえ作れば誰でもこれでgit challengeが開催できちゃうらしいです！やったね！
たしか12:00くらい ランチタイム ランチは隣のチームとかチューターさんとか人事の人とかが合わさって6人で食べました。
お弁当はなにやらお洒落で紐を引くと温まる系のアレです。
写真を見ていただければわかると思いますが、非常に見た目も綺麗でおいしかったです。 昼飯#mixi_git pic.twitter.com/lXDVVsofr2
&amp;mdash; そばや (@sobaya007) May 18, 2019 
13:07 ~ 16:30 競技 Slackに残っていたのでこれは正確な時刻がわかりました。
事前に戦略は練ってあって、最初の二問の割り振りはじゃんけんで適当に決めて、後は順次解けた人からどんどんやっていこう、みたいなかんじでした。
最初のほうはペースが良かったのですが、3問ほど明らかに配点がやばい問題が存在し、その問題は1問も解けませんでした&amp;hellip;
残念無念#mixi_git pic.twitter.com/gbMGNq0TJB
&amp;mdash; そばや (@sobaya007) May 18, 2019</description>
    </item>
    
    <item>
      <title>D言語でLLDも使ってリンクを高速化してみた</title>
      <link>https://sobaya007.github.io/2019/05/13/d%E8%A8%80%E8%AA%9E%E3%81%A7lld%E3%82%82%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%92%E9%AB%98%E9%80%9F%E5%8C%96%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</link>
      <pubDate>Mon, 13 May 2019 11:32:01 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/05/13/d%E8%A8%80%E8%AA%9E%E3%81%A7lld%E3%82%82%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%92%E9%AB%98%E9%80%9F%E5%8C%96%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</guid>
      <description>GOLDの続きです。
LLDとはなんぞや LLDとはリンカーの一種で、色々なアーキテクチャに対応している。goldより速いらしい。
多分OS標準のpackage managerで普通にインストールできる。
今回のモチベーション 前回の記事で「LLDが使えない!」という自体に陥り、仕方なくgoldを使う決意を固めていたのですが、諦めきれずにちょくちょく試しておりました。
今回D言語でうまく使う方法を無事発見できたのでメモがてら書いておこうと思いました。
TL;DR LLDはld.lldという名前の実行ファイルになっている。
-fuse-ld=lldとすれば置き換わると書いてあったので、試しに
&amp;gt; dmd test.d -L-fuse-ld=lld  としてみる。確かにコンパイルは通る。
しかし本当にLLDが使われているのかわからない。
LLDの「Using LLD」の項をよく読んでみると、
 LLD leaves its name and version number to a .comment section in an output. If you are in doubt whether you are successfully using LLD or not, run readelf --string-dump .comment &amp;lt;output-file&amp;gt; and examine the output. If the string “Linker: LLD” is included in the output, you are using LLD.</description>
    </item>
    
    <item>
      <title>DLSを直した話</title>
      <link>https://sobaya007.github.io/2019/05/09/dls%E3%82%92%E7%9B%B4%E3%81%97%E3%81%9F%E8%A9%B1/</link>
      <pubDate>Thu, 09 May 2019 12:03:42 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/05/09/dls%E3%82%92%E7%9B%B4%E3%81%97%E3%81%9F%E8%A9%B1/</guid>
      <description>動機 私はD言語を書くときNeovimを使っています。
プラグインとして以前まではdutylを使っていたのですが、昨今Language Server/なるものが流行りだしており、vim-lsp+dlsを使うようになりました。
しかしいざ使ってみるといくつかの機能がうまく動いていないように思われます。
READMEによると、DLSのサポートしている機能は
 コード補間 シンボルの定義へジャンプ 参照を検索 シンボルの名前変更 エラーチェック フォーマット シンボルの列挙 シンボルのハイライト ホバー時のドキュメント表示  となっています。
しかしvim-lspで例えば:LspDocumentFormatと打ってもDocument formatting not supported for dと言われてしまいます。
多分バグだと思ったので直してみようと思いました。
原因 LSP(Language Server Protocol)において、Language Serverの起動時にinitializeという命令が飛びます。
この命令のDLS側のハンドリングに問題(?)があったためうまく動いていないようでした。
Micrsoft公式のドキュメントによると、initialize時clientが送るデータの中にはcapabilitiesなるものが含まれており、server側が返す値にも同様にcapabilitiesなるものがあるようです。
ドキュメント内では、clientから送るものはThe capabilities provided by the client (editor or tool)であり、serverから返すものはThe capabilities the language server providesらしいです。
これを見る限り、clientの送るcapabilitiesは「以下のような機能を提供して欲しい」という意味であり、server側からのcapabilitiesは「要求された機能のうち、実際に提供できる機能は以下のものである」という意味であると考えられます。
しかしながらvim-lspではinitialize時にcapabilitiesをほとんど送っていません。
これでは先程の解釈によると「何の機能も要求していない」ということになります。したがって、DLSは当然何も返しません。
その結果vim-lsp側からは「DLSは何の機能も持たない」と解釈されてしまいます。これがnot supportedの原因でした。
この状況を素直に捉えれば、「仕様に則ったrequestを送っていないvim-lsp側に問題がある」となるのでしょうが、試してみたところなぜか他の言語のLanguage Serverは普通に動いてしまっています。 おかしいと思い各種Language Serverのコードを見に行きました。すると&amp;hellip;
 javascript-typescript-langserverより引用
const result: InitializeResult = { capabilities: { // Tell the client that the server works in FULL text document sync mode textDocumentSync: TextDocumentSyncKind.</description>
    </item>
    
    <item>
      <title>D言語でgoldを使ってリンクを高速化してみた</title>
      <link>https://sobaya007.github.io/2019/04/27/d%E8%A8%80%E8%AA%9E%E3%81%A7gold%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%92%E9%AB%98%E9%80%9F%E5%8C%96%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</link>
      <pubDate>Sat, 27 Apr 2019 23:33:31 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/04/27/d%E8%A8%80%E8%AA%9E%E3%81%A7gold%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%92%E9%AB%98%E9%80%9F%E5%8C%96%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</guid>
      <description>goldとはなんぞや goldとはELFバイナリ用のリンカーで、ldより高速なやつである。binutilsに入っているので、多分インストールしなくてもほぼ勝手に入っている。
今回のモチベーション 今回はあんまりD言語は関係ないのですが、D言語でのビルドステップを高速にしたい場面に直面したので「ビルドが遅い→どうせリンクが遅いんじゃね？」という適当な推論によりリンクを速くする術を捜しておりました。
先日とある密会に参加したところ教えていただいたのでブログに書いておこうとなりました。
ちなみにLLVMと何やら関連の深そうなLLDというのもあり、こちらはgoldの2倍速いらしい。リンカ界も日進月歩なんだなぁ。 LLDはなぜかDMDごしに呼び出すのはできなかったのでできたらまた記事書きます。
使い方 goldはld.goldという名前の実行ファイルになっている。 gccでもdmdでも、リンカオプションに-fuse-ld=goldとすると置き換わる。
&amp;gt; dmd main.o sub.o -L=-fuse-ld=gold  速度の比較 いったい何回やられたんだよってかんじですが、一応自分でも比較してみました。 適当に10000個関数をsub.dに作ってmain.dからそれらを呼び出す、というプログラムのリンク時間を測定しました。
ld : 4 secs, 986 ms, 351 μs, and 6 hnsecs gold : 1 sec, 699 ms, 670 μs, and 7 hnsecs  だいたい4倍くらい速くなっている。すごい。
比較用のコードはこちらにあります。 LLDはもっと速いらしいのでやってみたいなぁ。
追記 LDCコンパイラとかLLDリンカでもやってみたがLLDあまり速くなかった？LDCだとgoldと他が逆転？ https://t.co/BuiLfhNxYl pic.twitter.com/pijbhHVwHE
&amp;mdash; Shigeki Karita (@kari_tech) April 28, 2019  こんな情報を出していただきまして、もう少し調査してみました。 私の手元でも同様に実行してみたところ、確かにほぼ同じ結果に。そもそも各リンカーは本当に動いているのでしょうか？
実証 バイナリ周りは詳しくないのですが、どうもgoldを使うと実行ファイルのnote sectionにそれらしき情報が乗るらしい。
&amp;gt; dmd main.o sub.o -L-fuse-ld=gold &amp;gt; readelf -n main Displaying notes found in: .</description>
    </item>
    
    <item>
      <title>D言語で継承&#43;配列のバグがずっと残ってる件について</title>
      <link>https://sobaya007.github.io/2019/04/19/d%E8%A8%80%E8%AA%9E%E3%81%A7%E7%B6%99%E6%89%BF-%E9%85%8D%E5%88%97%E3%81%AE%E3%83%90%E3%82%B0%E3%81%8C%E3%81%9A%E3%81%A3%E3%81%A8%E6%AE%8B%E3%81%A3%E3%81%A6%E3%82%8B%E4%BB%B6%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</link>
      <pubDate>Fri, 19 Apr 2019 22:38:06 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/04/19/d%E8%A8%80%E8%AA%9E%E3%81%A7%E7%B6%99%E6%89%BF-%E9%85%8D%E5%88%97%E3%81%AE%E3%83%90%E3%82%B0%E3%81%8C%E3%81%9A%E3%81%A3%E3%81%A8%E6%AE%8B%E3%81%A3%E3%81%A6%E3%82%8B%E4%BB%B6%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</guid>
      <description>またバグの話ですね。 このバグは結構前に発見していて、issueも投げた&amp;hellip;気がするんですが、一向に直りませんね。かなり頻繁に出くわすんですが、他の環境だと違うのでしょうか？
今回のバグはこんなかんじで発生します。
 interface I { int x(); } class C : I { int x() { return 10; } } void main(){ I[] iList; C[] cList = [new C]; iList ~= cList; import std.stdio : writeln; writeln(iList[0].x); //私の環境では6と出た。 }   つまり、
 あるインターフェースIとそれを継承したクラスCがある。 I[]に対して、C[]を結合する(CでなくC[]!)。 I[]から取り出したI越しに仮想関数を呼ぶと、だいたい壊れている(変な値を返したり、SEGVしたりする)。  というもの。 いかがでしたか？ よくわかりませんが、バグっていることがわかりました！ 最後まで見ていただきありがとうございます。</description>
    </item>
    
    <item>
      <title>DMD2.085.0で謎のエラーが出てビルドできなくなる件について</title>
      <link>https://sobaya007.github.io/2019/04/11/dmd2.085.0%E3%81%A7%E8%AC%8E%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%8C%E5%87%BA%E3%81%A6%E3%83%93%E3%83%AB%E3%83%89%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%82%8B%E4%BB%B6%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</link>
      <pubDate>Thu, 11 Apr 2019 20:59:06 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/04/11/dmd2.085.0%E3%81%A7%E8%AC%8E%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%8C%E5%87%BA%E3%81%A6%E3%83%93%E3%83%AB%E3%83%89%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%82%8B%E4%BB%B6%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</guid>
      <description>実は前から気づいていたが、dmd2.085.0でとあるプロジェクトをビルドしようとしたところtym = x27とかいう謎のエラーを吐いてビルドできなくなってしまった。 ggってみても関連するものが見当たらない。 ブチキレたので調査をしてみた。
とりあえず現状報告。
OSはArch Linux。 dmdが2.085.0になったとき、エラーが起きた箇所の周辺コードを表示してくれるとかいう神機能を今更実装してくれたので試してみようと思い、使ってみたら上記の事態が発生。その時いろいろいじってはみたけどわからず。pacmanでバージョンを上げようとしても上がらなかったので「パッケージ管理者がバグに気づいて止めてるのかな？」と思いとりあえず放置。 ところが本日pacman -Syuしたところ、dmd2.0850が(バグったまま)入ってきやがった。おい。
ということで見つけた最小コードがこちら↓
 app.d
struct A { float e; } struct B { this(A[1]) {} }   これをdubのプロジェクトの中でビルドしようとすると、少なくとも私の環境では落ちます。ぜひお試しあれ。
ちなみにAのメンバーが浮動小数型だとバグりますが、整数型だと通ります。 また、Bのコンストラクタ引数の配列数を2以上にすると通ります。 意味がわからん&amp;hellip;</description>
    </item>
    
    <item>
      <title>D言語&#43;Shared Library&#43;Down castで型情報が死ぬ問題</title>
      <link>https://sobaya007.github.io/2019/04/10/d%E8%A8%80%E8%AA%9E-shared-library-down-cast%E3%81%A7%E5%9E%8B%E6%83%85%E5%A0%B1%E3%81%8C%E6%AD%BB%E3%81%AC%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Wed, 10 Apr 2019 16:27:25 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/04/10/d%E8%A8%80%E8%AA%9E-shared-library-down-cast%E3%81%A7%E5%9E%8B%E6%83%85%E5%A0%B1%E3%81%8C%E6%AD%BB%E3%81%AC%E5%95%8F%E9%A1%8C/</guid>
      <description>最近気づいた現象。(バグ？)
あるインターフェースIがあって、これを実装したクラスCがShared library 1にある。
これを型Iとして実行ファイル越しにShared library 2に送り、Cにダウンキャストする。
この時、実行ファイル側にCの情報がないとダウンキャストが失敗する。
具体的には以下のような状態。
 type.d
interface I { }  dll1.d
import type; class C : I {} I create() { return new C; } extern(C) string funcName() { return create.mangleof;}  dll2.d
import type; import dll1; void use(I i) { import std.stdio : writeln; writeln(cast(C)i); } extern(C) string funcName() { return use.mangleof;}  main.d
import std.experimental.all; import core.runtime; import core.sys.posix.dlfcn : dlsym, dlerror; import type; void main() { execute([&amp;quot;dmd&amp;quot;, &amp;quot;dll1.</description>
    </item>
    
    <item>
      <title>ブログ始めました</title>
      <link>https://sobaya007.github.io/2019/04/10/%E3%83%96%E3%83%AD%E3%82%B0%E5%A7%8B%E3%82%81%E3%81%BE%E3%81%97%E3%81%9F/</link>
      <pubDate>Wed, 10 Apr 2019 16:27:25 +0900</pubDate>
      
      <guid>https://sobaya007.github.io/2019/04/10/%E3%83%96%E3%83%AD%E3%82%B0%E5%A7%8B%E3%82%81%E3%81%BE%E3%81%97%E3%81%9F/</guid>
      <description>ご挨拶 誰に向けての挨拶なのかって話ですが、最初に挨拶を入れておくと収まりが良さそうなのでしておきます。
はじめましての方ははじめまして、そばやと申します。
2019年現在、東工大の修士1年生でCGH(Computer Generated Hologram)の研究をしております。
本ブログは日常の進捗中に思ったことをメモ書き程度に残しておこうというかんじで作られた技術系のものであります。
思ったことが特になければ何も書かれないかもしれませんが、そういうものということよろしくお願い致します。</description>
    </item>
    
  </channel>
</rss>